package profile

import (
	"crypto/rsa"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/getyoti/yoti-go-sdk/v3/cryptoutil"
	"github.com/getyoti/yoti-go-sdk/v3/requests"
	"github.com/getyoti/yoti-go-sdk/v3/share"
	"github.com/getyoti/yoti-go-sdk/v3/web"
	"github.com/getyoti/yoti-go-sdk/v3/yotierror"
	"github.com/getyoti/yoti-go-sdk/v3/yotiprotoattr"
)

func getProfileEndpoint(token, sdkID string) string {
	return fmt.Sprintf("/profile/%s?appId=%s", token, sdkID)
}

// GetActivityDetails requests information about a Yoti user using the one time
// use token generated by the Yoti login process. Don't call this directly, use yoti.GetActivityDetails
func GetActivityDetails(httpClient web.HttpClient, token, clientSdkId, apiUrl string, key *rsa.PrivateKey) (activity ActivityDetails, err error) {
	var decryptedToken string
	decryptedToken, err = cryptoutil.DecryptToken(token, key)
	if err != nil {
		return activity, errors.New("Unable to decrypt token")
	}

	headers := requests.AuthKeyHeader(&key.PublicKey)

	request, err := requests.SignedRequest{
		Key:        key,
		HTTPMethod: http.MethodGet,
		BaseURL:    apiUrl,
		Endpoint:   getProfileEndpoint(decryptedToken, clientSdkId),
		Headers:    headers,
		Body:       nil,
	}.Request()
	if err != nil {
		return
	}

	response, err := web.MakeRequest(httpClient, request, map[int]string{404: "Profile Not Found %[1]d"}, web.DefaultHTTPErrorMessages)
	if err != nil {
		return
	}

	if err != nil {
		return
	}
	return handleSuccessfulResponse(response, key)
}

func handleSuccessfulResponse(responseContent string, key *rsa.PrivateKey) (activityDetails ActivityDetails, err error) {
	var parsedResponse = profileDO{}

	if err = json.Unmarshal([]byte(responseContent), &parsedResponse); err != nil {
		return
	}

	if parsedResponse.Receipt.SharingOutcome != "SUCCESS" {
		err = ErrSharingFailure
	} else {
		var userAttributeList, applicationAttributeList *yotiprotoattr.AttributeList
		if userAttributeList, err = parseUserProfile(&parsedResponse.Receipt, key); err != nil {
			return
		}
		if applicationAttributeList, err = parseApplicationProfile(&parsedResponse.Receipt, key); err != nil {
			return
		}
		id := parsedResponse.Receipt.RememberMeID

		userProfile := NewUserProfile(userAttributeList)
		applicationProfile := NewApplicationProfile(applicationAttributeList)

		decryptedExtraData, errTemp := parseExtraData(&parsedResponse.Receipt, key)
		if errTemp != nil {
			log.Printf("Unable to decrypt ExtraData from the receipt. Error: %q", err)
			err = yotierror.MultiError{This: errTemp, Next: err}
		}

		extraData, errTemp := share.NewExtraData(decryptedExtraData)

		if errTemp != nil {
			log.Printf("Unable to parse ExtraData from the receipt. Error: %q", err)
			err = yotierror.MultiError{This: errTemp, Next: err}
		}

		timestamp, err := time.Parse(time.RFC3339Nano, parsedResponse.Receipt.Timestamp)
		if err != nil {
			log.Printf("Unable to read timestamp. Error: %q", err)
		}

		activityDetails = ActivityDetails{
			UserProfile:        userProfile,
			rememberMeID:       id,
			parentRememberMeID: parsedResponse.Receipt.ParentRememberMeID,
			timestamp:          timestamp,
			receiptID:          parsedResponse.Receipt.ReceiptID,
			ApplicationProfile: applicationProfile,
			extraData:          extraData,
		}
	}

	return activityDetails, err
}

func parseIsAgeVerifiedValue(byteValue []byte) (result *bool, err error) {
	stringValue := string(byteValue)

	var parseResult bool
	parseResult, err = strconv.ParseBool(stringValue)

	if err != nil {
		return nil, err
	}

	result = &parseResult

	return
}
